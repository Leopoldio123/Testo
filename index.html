<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ü–µ—á–∏</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            margin: 0;
            padding: 16px;
            box-sizing: border-box;
        }
        h2 { margin-top: 0; font-size: 18px; }
        .input-group { margin-bottom: 12px; }
        label { display: block; margin-bottom: 4px; font-size: 14px; color: var(--tg-theme-hint-color, #888); }
        input {
            width: 100%;
            padding: 12px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 16px;
            background: var(--tg-theme-secondary-bg-color, #f0f0f0);
            color: var(--tg-theme-text-color, #000);
        }
        button {
            width: 100%;
            padding: 14px;
            background-color: var(--tg-theme-button-color, #3390ec);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }
        button:active { opacity: 0.8; }
        .result-card {
            background: var(--tg-theme-secondary-bg-color, #f5f5f5);
            padding: 12px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid var(--tg-theme-button-color, #3390ec);
        }
        .result-title { font-weight: bold; margin-bottom: 8px; display: block; font-size: 16px;}
        .result-line { margin-bottom: 4px; font-size: 14px; }
        .error-msg { color: red; font-weight: bold; margin-top: 10px; white-space: pre-wrap; }
        pre { 
            white-space: pre-wrap; 
            font-family: monospace; 
            font-size: 12px; 
            color: var(--tg-theme-text-color);
        }
    </style>
</head>
<body>

    <h2>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—á–∏ (–º–º)</h2>
    
    <div class="input-group">
        <label>–î–ª–∏–Ω–∞ (L)</label>
        <input type="number" id="lenL" placeholder="5000">
    </div>
    <div class="input-group">
        <label>–®–∏—Ä–∏–Ω–∞ (W)</label>
        <input type="number" id="widW" placeholder="3000">
    </div>
    <div class="input-group">
        <label>–í—ã—Å–æ—Ç–∞ (H)</label>
        <input type="number" id="hgtH" placeholder="2500">
    </div>

    <button id="calcBtn">–†–ê–°–°–ß–ò–¢–ê–¢–¨</button>

    <div id="output"></div>

    <script>
        // --- –ù–ê–°–¢–†–û–ô–ö–ò ---
        const PANEL_LENGTH_MM = 6000;
        const MIN_OFFCUT_LENGTH_MM = 400;

        // –ü–æ–ø—ã—Ç–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Telegram
        let tg = window.Telegram.WebApp;
        try { tg.expand(); } catch(e) { console.log("Not in Telegram"); }

        // --- –ö–õ–ê–°–° –î–í–ò–ñ–ö–ê ---
        class NestingEngine {
            constructor(panelWidth) {
                this.panelWidth = panelWidth;
                this.panelLength = PANEL_LENGTH_MM;
                this.sheetsUsed = 0;
                this.offcuts = []; 
            }

            findBestOffcut(reqLen, reqWidth) {
                let bestIdx = -1;
                let minWaste = Infinity;

                for (let i = 0; i < this.offcuts.length; i++) {
                    const offcut = this.offcuts[i];
                    if (offcut.length >= reqLen && offcut.width >= reqWidth) {
                        const waste = (offcut.length * offcut.width) - (reqLen * reqWidth);
                        if (waste < minWaste) {
                            minWaste = waste;
                            bestIdx = i;
                        }
                    }
                }
                return bestIdx;
            }

            getPiece(length, width) {
                const idx = this.findBestOffcut(length, width);

                if (idx !== -1) {
                    // –ë–µ—Ä–µ–º –æ—Å—Ç–∞—Ç–æ–∫
                    const sourcePiece = this.offcuts.splice(idx, 1)[0];
                    
                    const remLen = sourcePiece.length - length;
                    if (remLen >= MIN_OFFCUT_LENGTH_MM) {
                        this.offcuts.push({ length: remLen, width: sourcePiece.width });
                    }
                    
                    const remWidth = sourcePiece.width - width;
                    if (remWidth >= 100) {
                        this.offcuts.push({ length: length, width: remWidth });
                    }

                } else {
                    // –ù–æ–≤—ã–π –ª–∏—Å—Ç
                    this.sheetsUsed++;

                    const remLen = this.panelLength - length;
                    if (remLen >= MIN_OFFCUT_LENGTH_MM) {
                        this.offcuts.push({ length: remLen, width: this.panelWidth });
                    }

                    const remWidth = this.panelWidth - width;
                    if (remWidth >= 100) {
                        this.offcuts.push({ length: length, width: remWidth });
                    }
                }
            }

            processSurface(totalLength, cutLength) {
                // –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ 0 –∏–ª–∏ –ø–ª–æ—Ö–∏—Ö –¥–∞–Ω–Ω—ã—Ö
                if (!cutLength || !totalLength) return;

                const fullStrips = Math.floor(totalLength / this.panelWidth);
                const lastStripWidth = totalLength % this.panelWidth;

                for (let i = 0; i < fullStrips; i++) {
                    this.getPiece(cutLength, this.panelWidth);
                }

                if (lastStripWidth > 0) {
                    this.getPiece(cutLength, lastStripWidth);
                }
            }
        }

        // --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---
        function runEngine(L, W, H, panelWidth) {
            const engine = new NestingEngine(panelWidth);
            
            const floorCeilCutLen = W + 200; 
            const floorCeilCoverLen = L;
            
            // –ü–æ–ª –∏ –ü–æ—Ç–æ–ª–æ–∫
            engine.processSurface(floorCeilCoverLen, floorCeilCutLen); // –ü–æ–ª
            engine.processSurface(floorCeilCoverLen, floorCeilCutLen); // –ü–æ—Ç–æ–ª–æ–∫
            
            // –°—Ç–µ–Ω—ã (L - –¥–ª–∏–Ω–∞ –ø–æ–∫—Ä—ã—Ç–∏—è, H - –≤—ã—Å–æ—Ç–∞ –ø–∞–Ω–µ–ª–∏)
            engine.processSurface(L, H); // –°—Ç–µ–Ω–∞ –õ
            engine.processSurface(L, H); // –°—Ç–µ–Ω–∞ –ü

            // –¢–æ—Ä—Ü—ã (W - —à–∏—Ä–∏–Ω–∞ –ø–æ–∫—Ä—ã—Ç–∏—è, H - –≤—ã—Å–æ—Ç–∞ –ø–∞–Ω–µ–ª–∏)
            engine.processSurface(W, H); // –ó–∞–¥–Ω—è—è
            engine.processSurface(W, H); // –î–≤–µ—Ä–∏

            return engine;
        }

        function formatReport(width, engine) {
            let html = '<div class="result-card">';
            html += '<span class="result-title">üõ† –ü–∞–Ω–µ–ª–∏ ' + width + '–º–º</span>';
            html += '<div class="result-line">üì¶ –õ–∏—Å—Ç–æ–≤ 6000–º–º: <b>' + engine.sheetsUsed + ' —à—Ç</b></div>';
            
            const counts = {};
            engine.offcuts.forEach(o => {
                const key = o.length + 'x' + o.width;
                counts[key] = (counts[key] || 0) + 1;
            });

            let offcutsStr = "";
            for (const [size, count] of Object.entries(counts)) {
                offcutsStr += '‚Ä¢ ' + size + '–º–º: ' + count + ' —à—Ç\n';
            }
            if (!offcutsStr) offcutsStr = "–ù–µ—Ç –ø–æ–ª–µ–∑–Ω—ã—Ö –æ—Å—Ç–∞—Ç–∫–æ–≤";

            html += '<div class="result-line">‚úÇÔ∏è –û—Å—Ç–∞—Ç–∫–∏:</div>';
            html += '<pre>' + offcutsStr + '</pre>';
            html += '</div>';
            return html;
        }

        // --- –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø ---
        function handleCalculate() {
            const output = document.getElementById('output');
            output.innerHTML = "–°—á–∏—Ç–∞—é..."; // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä–∞–±–æ—Ç—ã
            
            try {
                // –ß—Ç–µ–Ω–∏–µ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–≤–æ–¥–∞
                const L = parseInt(document.getElementById('lenL').value);
                const W = parseInt(document.getElementById('widW').value);
                const H = parseInt(document.getElementById('hgtH').value);

                if (isNaN(L) || isNaN(W) || isNaN(H)) {
                    alert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è —Ü–∏—Ñ—Ä–∞–º–∏!");
                    output.innerHTML = "";
                    return;
                }

                // –û—á–∏—Å—Ç–∫–∞
                output.innerHTML = ""; 

                // –†–∞—Å—á–µ—Ç 1000
                const engine1000 = runEngine(L, W, H, 1000);
                output.innerHTML += formatReport(1000, engine1000);

                // –†–∞—Å—á–µ—Ç 1190
                const engine1190 = runEngine(L, W, H, 1190);
                output.innerHTML += formatReport(1190, engine1190);
                
                // –í–∏–±—Ä–∞—Ü–∏—è –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞)
                if(tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');

            } catch (error) {
                // –ï–°–õ–ò –û–®–ò–ë–ö–ê ‚Äî –ü–û–ö–ê–ñ–ï–ú –ï–Å –ù–ê –≠–ö–†–ê–ù–ï
                output.innerHTML = '<div class="error-msg">–û–®–ò–ë–ö–ê: ' + error.message + '<br>' + error.stack + '</div>';
            }
        }

        // –ü—Ä–∏–≤—è–∑–∫–∞ –∫–Ω–æ–ø–∫–∏ (—Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π —Å–ø–æ—Å–æ–±)
        document.getElementById('calcBtn').addEventListener('click', handleCalculate);

    </script>
</body>
</html>
